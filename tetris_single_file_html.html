<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris — Single File</title>
  <style>
    :root{--bg:#111;--panel:#0f1720;--accent:#22c1c3;--muted:#94a3b8}
    *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018 0%, #041018 100%);color:#e6eef6}
    .wrap{display:flex;gap:24px;align-items:flex-start;justify-content:center;padding:28px}
    .board{background:var(--panel);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
    canvas{display:block;background:#08121a;border-radius:6px}
    .sidebar{width:220px;background:linear-gradient(180deg,#081827,#05202a);padding:14px;border-radius:12px}
    .hud{display:flex;flex-direction:column;gap:12px}
    .box{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px}
    h1{font-size:18px;margin:0 0 6px 0}
    .muted{color:var(--muted);font-size:13px}
    .big{font-size:22px;font-weight:700}
    .controls{margin-top:6px;font-size:13px}
    button{appearance:none;border:0;padding:8px 10px;border-radius:8px;background:linear-gradient(180deg,#0f1728,#07202a);color:#cfeef0;cursor:pointer}
    .footer{margin-top:12px;color:var(--muted);font-size:12px}
    .nextCanvas, .holdCanvas{background:#061118;border-radius:6px;width:92px;height:92px}
    .row{display:flex;gap:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board box">
      <canvas id="game" width="240" height="480"></canvas>
    </div>
    <div class="sidebar box">
      <div class="hud">
        <div>
          <h1>Tetris</h1>
          <div class="muted">HTML5 + Vanilla JS — single file</div>
        </div>
        <div class="row">
          <div style="flex:1">
            <div class="box">
              <div class="muted">Score</div>
              <div id="score" class="big">0</div>
              <div class="muted">Level <span id="level">1</span></div>
            </div>
          </div>
          <div style="width:104px">
            <div class="box" style="padding:8px;text-align:center">
              <div class="muted">Next</div>
              <canvas id="next" class="nextCanvas" width="92" height="92"></canvas>
            </div>
            <div style="height:8px"></div>
            <div class="box" style="padding:8px;text-align:center">
              <div class="muted">Hold</div>
              <canvas id="hold" class="holdCanvas" width="92" height="92"></canvas>
            </div>
          </div>
        </div>

        <div class="box controls">
          <div class="muted">Controls</div>
          <div>← → : Move</div>
          <div>↑ : Rotate</div>
          <div>↓ : Soft drop</div>
          <div>Space : Hard drop</div>
          <div>C : Hold</div>
          <div>P : Pause</div>
        </div>

        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="start">Start</button>
          <button id="reset">Reset</button>
        </div>

        <div class="footer">Created for you — open the canvas file in a browser to play.</div>
      </div>
    </div>
  </div>

  <script>
  // ---- TETRIS core (compact, readable) ----
  const COLS = 10, ROWS = 20, BLOCK = 24;
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const nextCanvas = document.getElementById('next').getContext('2d');
  const holdCanvas = document.getElementById('hold').getContext('2d');

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const startBtn = document.getElementById('start');
  const resetBtn = document.getElementById('reset');

  // Colors for pieces
  const COLORS = [null,'#00ffff','#0000ff','#ffa500','#ffff00','#00ff00','#800080','#ff0000'];

  // Tetromino shapes (matrix of rotation states)
  const SHAPES = {
    I: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
    ],
    J: [
      [[2,0,0],[2,2,2],[0,0,0]],[[0,2,2],[0,2,0],[0,2,0]],[[0,0,0],[2,2,2],[0,0,2]],[[0,2,0],[0,2,0],[2,2,0]]
    ],
    L: [
      [[0,0,3],[3,3,3],[0,0,0]],[[0,3,0],[0,3,0],[0,3,3]],[[0,0,0],[3,3,3],[3,0,0]],[[3,3,0],[0,3,0],[0,3,0]]
    ],
    O: [
      [[4,4],[4,4]]
    ],
    S: [
      [[0,5,5],[5,5,0],[0,0,0]],[[0,5,0],[0,5,5],[0,0,5]]
    ],
    T: [
      [[0,6,0],[6,6,6],[0,0,0]],[[0,6,0],[0,6,6],[0,6,0]],[[0,0,0],[6,6,6],[0,6,0]],[[0,6,0],[6,6,0],[0,6,0]]
    ],
    Z: [
      [[7,7,0],[0,7,7],[0,0,0]],[[0,0,7],[0,7,7],[0,7,0]]
    ]
  };

  function createMatrix(w,h){
    const m = [];
    while(h--) m.push(new Array(w).fill(0));
    return m;
  }

  let grid = createMatrix(COLS, ROWS);

  function drawCell(x,y,val,context=ctx){
    const px = x*BLOCK, py = y*BLOCK;
    context.fillStyle = val ? COLORS[val] : '#061218';
    context.fillRect(px,py,BLOCK-1,BLOCK-1);
    if(val){
      context.strokeStyle = 'rgba(0,0,0,0.4)';
      context.strokeRect(px,py,BLOCK-1,BLOCK-1);
    }
  }

  function drawGrid(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) drawCell(c,r,grid[r][c]);
  }

  function randPiece(){
    const types = Object.keys(SHAPES);
    const t = types[Math.floor(Math.random()*types.length)];
    return makePiece(t);
  }

  function makePiece(type){
    const states = SHAPES[type];
    const state = JSON.parse(JSON.stringify(states[0]));
    const idMap = {I:1,J:2,L:3,O:4,S:5,T:6,Z:7};
    return {type, states, rotation:0, shape:states[0], x: Math.floor((COLS - states[0][0].length)/2), y: -1, id:idMap[type]};
  }

  function rotate(piece,dir){
    const len = piece.states.length;
    piece.rotation = (piece.rotation + dir + len) % len;
    piece.shape = piece.states[piece.rotation];
  }

  function collide(piece,grid,ox=0,oy=0){
    const s = piece.shape;
    for(let r=0;r<s.length;r++){
      for(let c=0;c<s[r].length;c++){
        if(!s[r][c]) continue;
        const x = piece.x + c + ox;
        const y = piece.y + r + oy;
        if(x<0 || x>=COLS || y>=ROWS) return true;
        if(y>=0 && grid[y][x]) return true;
      }
    }
    return false;
  }

  function merge(piece,grid){
    piece.shape.forEach((row,r)=>row.forEach((val,c)=>{
      const x = piece.x + c, y = piece.y + r;
      if(val && y>=0) grid[y][x] = piece.id;
    }));
  }

  function sweep(){
    let lines = 0;
    outer: for(let r=ROWS-1;r>=0;r--){
      for(let c=0;c<COLS;c++) if(!grid[r][c]) continue outer;
      const row = grid.splice(r,1)[0].fill(0);
      grid.unshift(row);
      lines++; r++; // recheck same row index after splice
    }
    return lines;
  }

  // Game state
  let current = null, next = null, hold = null, canHold = true;
  let score = 0, level = 1, linesCleared = 0;
  let dropInterval = 800, lastTime = 0; let dropCounter = 0;
  let running = false, paused = false, gameOver = false;

  function newPiece(){
    current = next || randPiece();
    next = randPiece();
    current.x = Math.floor((COLS - current.shape[0].length)/2);
    current.y = -1;
    canHold = true;
    if(collide(current,grid)) { gameOver = true; running=false; }
    drawNext(); drawHold();
  }

  function hardDrop(){
    while(!collide(current,grid,0,1)) current.y++;
    lockPiece();
  }

  function lockPiece(){
    merge(current,grid);
    const scoredLines = sweep();
    if(scoredLines){
      const points = [0,40,100,300,1200];
      score += points[scoredLines] * level;
      linesCleared += scoredLines;
      level = Math.floor(linesCleared/10) + 1;
      dropInterval = Math.max(80, 800 - (level-1)*60);
    }
    scoreEl.textContent = score;
    levelEl.textContent = level;
    newPiece();
  }

  function holdPiece(){
    if(!canHold) return;
    if(!hold){ hold = { ...current }; newPiece(); }
    else { const tmp = current; current = { ...hold }; hold = { ...tmp }; current.x = Math.floor((COLS - current.shape[0].length)/2); current.y = -1; }
    canHold = false; drawHold();
  }

  function update(time=0){
    if(!running) return;
    const delta = time - lastTime; lastTime = time;
    if(paused) return requestAnimationFrame(update);
    dropCounter += delta;
    if(dropCounter > dropInterval){
      dropCounter = 0;
      if(!collide(current,grid,0,1)) current.y++;
      else lockPiece();
    }
    drawGrid(); drawPiece(current);
    requestAnimationFrame(update);
  }

  function drawPiece(piece,context=ctx,offsetX=0,offsetY=0){
    if(!piece) return;
    piece.shape.forEach((row,r)=>row.forEach((val,c)=>{
      if(val){
        const x = piece.x + c + offsetX; const y = piece.y + r + offsetY;
        if(y>=0) drawCell(x,y,piece.id,context);
      }
    }));
  }

  function drawNext(){
    nextCanvas.clearRect(0,0,92,92);
    if(!next) return;
    const s = next.shape; const size = s.length; const pad = Math.floor((92 - size*BLOCK)/2);
    nextCanvas.save(); nextCanvas.translate(pad,pad);
    for(let r=0;r<size;r++) for(let c=0;c<size;c++){
      const v = s[r][c]; if(v) {
        nextCanvas.fillStyle = COLORS[next.id];
        nextCanvas.fillRect(c*BLOCK, r*BLOCK, BLOCK-2, BLOCK-2);
        nextCanvas.strokeStyle = 'rgba(0,0,0,0.4)'; nextCanvas.strokeRect(c*BLOCK, r*BLOCK, BLOCK-2, BLOCK-2);
      }
    }
    nextCanvas.restore();
  }

  function drawHold(){
    holdCanvas.clearRect(0,0,92,92);
    if(!hold) return;
    const s = hold.shape; const size = s.length; const pad = Math.floor((92 - size*BLOCK)/2);
    holdCanvas.save(); holdCanvas.translate(pad,pad);
    for(let r=0;r<size;r++) for(let c=0;c<size;c++){
      const v = s[r][c]; if(v){
        holdCanvas.fillStyle = COLORS[hold.id];
        holdCanvas.fillRect(c*BLOCK, r*BLOCK, BLOCK-2, BLOCK-2);
        holdCanvas.strokeStyle = 'rgba(0,0,0,0.4)'; holdCanvas.strokeRect(c*BLOCK, r*BLOCK, BLOCK-2, BLOCK-2);
      }
    }
    holdCanvas.restore();
  }

  // Input
  document.addEventListener('keydown', e=>{
    if(!running) return;
    if(e.key === 'ArrowLeft'){ if(!collide(current,grid,-1,0)) current.x--; }
    else if(e.key === 'ArrowRight'){ if(!collide(current,grid,1,0)) current.x++; }
    else if(e.key === 'ArrowDown'){ if(!collide(current,grid,0,1)) current.y++; else lockPiece(); }
    else if(e.key === 'ArrowUp'){ rotate(current,1); if(collide(current,grid)) rotate(current,-1); }
    else if(e.code === 'Space'){ e.preventDefault(); hardDrop(); }
    else if(e.key.toLowerCase() === 'c'){ holdPiece(); }
    else if(e.key.toLowerCase() === 'p'){ paused = !paused; }
    drawGrid(); drawPiece(current);
  });

  startBtn.addEventListener('click', ()=>{
    if(gameOver) resetState();
    if(!running){ running = true; lastTime = performance.now(); requestAnimationFrame(update); }
  });

  resetBtn.addEventListener('click', ()=> resetState());

  function resetState(){
    grid = createMatrix(COLS,ROWS);
    next = randPiece(); current = null; hold = null;
    score = 0; level = 1; linesCleared = 0; dropInterval = 800; scoreEl.textContent = '0'; levelEl.textContent = '1';
    running = true; paused = false; gameOver = false; canHold = true;
    newPiece(); drawGrid(); requestAnimationFrame(update);
  }

  // initialize
  resetState();

  // Small helper: auto-scale canvas drawing to block size
  function scaleCanvas(){
    cvs.style.width = `${COLS*BLOCK}px`;
    cvs.style.height = `${ROWS*BLOCK}px`;
  }
  scaleCanvas();

  // friendly touch: pause on focus loss
  window.addEventListener('blur', ()=>{ paused = true; });
  </script>
</body>
</html>